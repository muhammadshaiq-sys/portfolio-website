<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Credit Fraud Detection</title>
    <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap">
  <style>
    :root{
      --bg-deep:#030712;        
      --node:#e5f4ff;           
      --link-a:#22d3ee;         
      --link-b:#60a5fa;         
    }

    html{scroll-behavior:smooth;}

    body{
      font-family:'Roboto',sans-serif;
      background:var(--bg-deep);
      min-height:100vh;
      margin:0;
      padding:0;
      display:flex;
      justify-content:center;
      align-items:flex-start;   
      color:white;
      opacity:0;               
      transition:opacity .5s ease-in-out;
      overflow-y:auto;         
      overflow-x:hidden;       
    }

   
    #bgCanvas{
      position:fixed;
      inset:0;
      z-index:-2;
      width:100%;
      height:100%;
      display:block;
      pointer-events:none;
    }

 
    .texture{
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background-image:
        radial-gradient(rgba(255,255,255,0.03) 1px, transparent 1.2px);
      background-size:12px 12px;
      mix-blend-mode:soft-light;
      opacity:.9;
    }
    .vignette{
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background:
        radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,.35) 100%);
    }

    .content{
      position:relative;
      z-index:1;
      max-width:800px;
      text-align:center;
      padding:2rem;
      margin:2rem 1rem 4rem; /* breathing room at top/bottom */
    }
    h1{font-size:3.5rem;font-weight:700;margin-bottom:1.5rem;}
    p{font-size:1rem;line-height:1.8;margin-bottom:1.5rem;}

    /* Bullets removed (semantic UL preserved) */
    ul.point-form{list-style:none;padding-left:0;margin:0;}
    ul.point-form li{margin-bottom:1rem;}

    .back-button{
      display:inline-block;margin-top:2rem;padding:10px 20px;
      border:2px solid #f39c12;border-radius:5px;text-decoration:none;color:#f39c12;
      transition:background-color .3s ease,color .3s ease;
    }
    .back-button:hover{background-color:#f39c12;color:white;}

    img{display:block;margin:0 auto;}
    .contact-button{
       transition: all 0.3s ease;
    }
    .contact-button:hover{
        background:rgb(158, 33, 216);
        color:white;
    }
  </style>
</head>
<body>

  <!-- Background layers -->
  <canvas id="bgCanvas" aria-hidden="true"></canvas>
  <div class="texture" aria-hidden="true"></div>
  <div class="vignette" aria-hidden="true"></div>

  <div class="content">
    <h1 style="font-size: 2.5rem" class="mt-4">Credit Fraud Detection</h1>
    <p style="font-size: 1rem;">
      Credit card fraud detection aims to identify unauthorized or suspicious transactions using machine learning techniques before financial loss occurs. Since fraudulent transactions are rare and often subtle, the system focuses on learning hidden patterns from historical data while maintaining high accuracy.

Another key aim is to maximize fraud detection (recall) while minimizing false alerts that can inconvenience genuine customers. An effective fraud detection system supports real-time decision-making, reduces financial risk for institutions, and enhances trust in digital payment systems.
    </p>

    <img src="Screenshot 2025-12-22 201953.png" alt="kaer" class="mt-2 mb-2 rounded-lg" style="width: 400px; height: auto;">
    <p class="text-md mb-4" style="font-size: 0.7rem;">Credit Fraud ROC Curve</p>

    <h2 style="font-size: 2rem" class="mt-4">Key Features</h2>
    <ul class="point-form">
      <li>Real-time transaction monitoring</li>
      <li>Machine learningâ€“based fraud classification</li>
      <li>Handling highly imbalanced datasets</li>
      <li>Model interpretability for trust and compliance</li>
    </ul>

    <h3 style="font-size: 2rem" class="mt-4">Technologies Used</h3>
    <ul class="point-form">
      <li>Python, Pandas, NumPy</li>
      <li>Scikit-learn, Imbalanced-learn</li>
      <li>Logistic Regression, Random Forest, Gradient Boosting</li>
      <li>Precision, Recall, F1-Score, ROC-AUC</li>
      <li>Matplotlib / Seaborn</li>
    </ul>

    <p class="text-lg mt-4">
      <a href="https://github.com/muhammadshaiq-sys/Credit-Fraud-Detection" class="contact-button px-6 py-3 border rounded transition" target="_blank">Concept</a>
    </p>

    <a href="#" class="back-button mb-16" id="backToProjects">Back to Projects</a>
  </div>

  <script>
    // Fade-in on load
    window.addEventListener('load', () => { document.body.style.opacity = 1; });

    // Back link with fade-out
    document.getElementById('backToProjects').addEventListener('click', function (e) {
      e.preventDefault();
      document.body.style.opacity = 0;
      setTimeout(() => { window.location.href = "../project.html"; }, 500);
    });
  </script>

  
  <script>
    (() => {
      const canvas = document.getElementById('bgCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      let width, height, dpr, rafId;
      let points = [];
      let t = 0;

      function resize() {
        dpr = Math.min(window.devicePixelRatio || 1, 2);
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        spawnPoints();
      }

      function spawnPoints() {
        const density = 0.00018; // points per pixel
        const count = Math.max(80, Math.min(280, Math.floor(width * height * density)));
        points = [];
        for (let i = 0; i < count; i++) {
          points.push({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 0.35,
            vy: (Math.random() - 0.5) * 0.35,
            r: 1 + Math.random() * 1.2,
            a: 0.45 + Math.random() * 0.4 // node brightness
          });
        }
      }

      function step() {
        // Clear crisp (no trails)
        ctx.clearRect(0, 0, width, height);

        // Update positions with gentle curl
        t += 0.0025;
        const curlAmp = 0.25;
        for (const p of points) {
          const ax = Math.sin((p.y + t * 700) * 0.002) * curlAmp;
          const ay = Math.cos((p.x - t * 700) * 0.002) * curlAmp;
          p.vx += ax * 0.002;
          p.vy += ay * 0.002;

          p.x += p.vx;
          p.y += p.vy;

          // Soft wrap
          if (p.x < -10) p.x = width + 10;
          if (p.x > width + 10) p.x = -10;
          if (p.y < -10) p.y = height + 10;
          if (p.y > height + 10) p.y = -10;
        }

        // Draw links (nearby connections)
        const maxDist = Math.min(140, Math.max(90, Math.hypot(width, height) * 0.08));
        const maxDist2 = maxDist * maxDist;

        for (let i = 0; i < points.length; i++) {
          const a = points[i];
          let links = 0;
          for (let j = i + 1; j < points.length; j++) {
            const b = points[j];
            const dx = a.x - b.x, dy = a.y - b.y;
            const d2 = dx * dx + dy * dy;
            if (d2 <= maxDist2) {
              if (links++ > 4) continue;

              const d = Math.sqrt(d2);
              const alpha = 1 - d / maxDist; 

              const grad = ctx.createLinearGradient(a.x, a.y, b.x, b.y);
              grad.addColorStop(0, `rgba(34, 211, 238, ${alpha * 0.55})`); // cyan
              grad.addColorStop(1, `rgba(96, 165, 250, ${alpha * 0.55})`);  // blue

              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.strokeStyle = grad;
              ctx.lineWidth = 1;
              ctx.stroke();
            }
          }
        }

        // Draw nodes (soft glow)
        for (const p of points) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(229,244,255,${p.a})`;
          ctx.shadowColor = 'rgba(180,220,255,0.35)';
          ctx.shadowBlur = 6;
          ctx.fill();
        }
        ctx.shadowBlur = 0;

        rafId = requestAnimationFrame(step);
      }

      function start() {
        cancelAnimationFrame(rafId);
        resize();
        step();
      }

      function renderStill() {
        cancelAnimationFrame(rafId);
        resize();
        // draw one still frame
        step();
        cancelAnimationFrame(rafId);
      }

      window.addEventListener('resize', start, { passive: true });
      const mql = window.matchMedia('(prefers-reduced-motion: reduce)');
      function handleMotion() { mql.matches ? renderStill() : start(); }
      if (mql.addEventListener) mql.addEventListener('change', handleMotion);
      else mql.addListener(handleMotion);

      handleMotion();
    })();
  </script>
</body>
</html>
